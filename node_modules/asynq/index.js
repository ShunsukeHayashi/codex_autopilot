'use strict';

/**
 * 現在のRunnerインスタンスです。
 * @api private
 */
var current = null;

/**
 * Array.prototype.sliceの高速版です。
 * @api private
 */
var slice = function(args, offset){
	var l = args.length - offset;
	if(l <= 0){
		return [];
	}
	
	var array = new Array(l);
	for(var i = 0; i < l; i++){
		array[i] = args[offset + i];
	}
	
	return array;
};

/**
 * Array.isArrayのショートカットです。
 * @api private
 */
var isArray = Array.isArray;

/**
 * Function.prototype.applyを高速実行します。
 * @api private
 */
var apply = (function(){
	var defaultContext = (function(){return this;})();

	return function(fn, context, args){
		var noContext = context === defaultContext;
		
		switch(args.length){
		case 0:
			if(noContext){
				return fn();
			}
			return fn.call(context);
		case 1:
			if(noContext){
				return fn(args[0]);
			}
			return fn.call(context, args[0]);
		case 2:
			if(noContext){
				return fn(args[0], args[1]);
			}
			return fn.call(context, args[0], args[1]);
		default:
			return fn.apply(context);
		}
	};	
})();

/**
 * パラメータの値がObject型であるかをチェックします。
 * @api private
 */
var isObject = function(arg) {
	return typeof arg === 'object' && arg !== null;
};

/**
 * パラメータの値がFunction型であるかをチェックします。
 * @api private
 */
var isFunction = function(arg) {
	return typeof arg === 'function';
};

/**
 * パラメータの値がPromise型であるかをチェックします。
 * @api private
 */
var isPromise = function(arg){
	if(!arg){
		return false;
	}
	if(arg.constructor === Promise){
		return true;
	}
	if(!isFunction(arg.then)){
		return false;
	}
	
	return true;
};

/**
 * パラメータの値をPromiseに変換します。
 * @api private
 */
var toPromise = function(obj, context, args){
	if(isPromise(obj)){
		return obj;
	}

	if(isGeneratorFunction(obj) || isGenerator(obj)){
		return apply(asynq, context, [obj].concat(args));
	}
	
	if(isArray(obj)){
		var promises = [];
		for(var i = 0, l = obj.length; i < l; i++){
			promises[i] = toPromise(obj[i], context, args);
		}
		return Promise.all(promises);
	}
	
	if(isFunction(obj)){
		return delegate.call(context, obj);
	}
	
	return null;
};

/**
 * パラメータがGeneratorFunctionであるかをチェックします。
 * @api private
 */
var isGeneratorFunction = function(arg) {
	return isFunction(arg)
			&& arg.constructor.name === 'GeneratorFunction';
};

/**
 * パラメータがGeneratorであるかをチェックします。
 * @api private
 */
var isGenerator = function(arg) {
	if(!isObject(arg)){
		return false;
	}
	
	if(arg.constructor.constructor.name !== 'GeneratorFunction'){
		return false;
	}

	return isFunction(arg.next) && isFunction(arg.throw);
};

/**
 * Node.jsの標準スタイルの非同期関数をPromiseに変換して返します。
 * 非同期関数とは、最初の引数にエラー、以降実行結果が渡されるコールバック関数を要求する関数です。
 * 
 * <code>
 * fs.readdir("any", function(err, names){
 *   //any code
 * });
 * </code>
 * 
 * 上記のようなコードを、以下のようなコードに変換します。
 * <code>
 * new Promise(function(resolve, reject){
 *     fs.readdir("any", function(err, names){
 *         if(err){
 *             reject(err);
 *             return;
 *         }
 *         
 *         resolve(names);
 *     });
 * });
 * 
 * @api private
 */
var delegate = function(fn){
	var context = this;
	var args = slice(arguments, 1);

	return new Promise(function(resolve, reject){
		args[args.length] = function(err){
			if(err){
				reject(err);
				return;
			}
			
			if(arguments.length <= 2){
				resolve(arguments[1]);
				return;
			}

			resolve(slice(arguments, 1));
		};
		apply(fn, context, args);
	});
};

/**
 * 指定のジェネレータを実行します。
 * 
 * ジェネレータ以外の値が渡された場合は、関数の場合は実行結果、その他の場合はその値を結果とするPromiseを返します。
 * 
 * @param {Generator|GeneratorFunction} generator ジェネレータ
 * @return {Promise} ジェネレータの実行結果を返すPromise
 */
var asynq = function(generator){
	var context = this;
	var args = slice(arguments, 1);

	return new Promise(function(resolve, reject){
		if(isFunction(generator)){
			generator = apply(generator, context, args);
		}
		if(!isGenerator(generator)){
			return resolve(generator);
		}

		var runner = new Runner(generator, context, args, resolve, reject);
		runner.run(false);
	});
};

/**
 * asynq関数を実行する関数返します。
 * 
 * @param {Generator|GeneratorFunction} generator ジェネレータ
 * @return {Function} asynq関数に委譲する関数
 */
asynq.wrap = function(generator){
	return function(){
		var args = slice(arguments, 0);
		args.unshift(generator);
		return apply(asynq, this, args)
	};
};

/**
 * Node.jsの標準スタイルの非同期関数向けのコールバック関数を返します。
 * 
 * 以下のような方法で非同期関数のコールバックとして渡すことにより、
 * コールバックで受け取った結果を戻り値のように扱うことができます。
 * 
 * <code>
 * asynq(function*(){
 *   var names = yield fs.readdir("any", asynq.callback);
 * });
 * </code>
 * 
 * @type {Function}
 */
Object.defineProperty(asynq, 'callback', {
	get : function(){
		var executor = current;

		return function(err){
			var args = slice(arguments, 1);

			setImmediate(function(){
				if(err){
					executor.run(true, err);
					return;
				}
				
				if(args.length <= 1){
					executor.run(false, args[0]);
					return;
				}

				executor.run(false, args);
			});
		};
	}
});

/**
 * asynq関数によって作成される実行単位です。
 * @api private
 */
var Runner = function(generator, context, args, resolve, reject){
	this.generator = generator;
	this.context = context;
	this.args = args;
	this.resolve = resolve;
	this.reject = reject;

	var self = this;
	this.onFulfilled = function(value){
		self.run(false, value);
	};
	this.onRejected = function(err){
		self.run(true, err);
	};
};

/**
 * タスクを実行します。
 * @api private
 */
Runner.prototype.run = function(fail, value){
	current = this;

	var result;
	try{
		if(fail){
			result = this.generator.throw(value);
		}else{
			result = this.generator.next(value);
		}
	}catch(e){
		this.reject(e);
		return;
	}
	
	if(result.done){
		this.resolve(result.value);
		return;
	}

	var promise = toPromise(result.value, this.context, this.args);
	if(promise){
		promise.then(this.onFulfilled, this.onRejected);
	}
};

//export
module.exports = asynq;
